<!--
    Encryption Hub
    Copyright (C) 2025  MD AZEEM

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<!--
Encryption Hub
Copyright (C) 2025  MD AZEEM

This software includes original code written by MD AZEEM and may include third-party libraries:

Third-party libraries used:
1. Tailwind CSS (https://tailwindcss.com/)
   - License: MIT
2. Google Fonts - Inter (https://fonts.google.com/specimen/Inter)
   - License: SIL Open Font License
3. CryptoJS (https://cdnjs.com/libraries/crypto-js)
   - License: MIT

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.

---

Special Notes:
- Tailwind CSS and CryptoJS are used under their respective MIT licenses.
- Google Fonts are used under the SIL Open Font License.
- Redistribution of the software must comply with GPL-3.0 for original code and preserve notices for third-party libraries.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Encryption 3.0</title>
    <!-- Placeholder favicons removed as they point to local paths -->
         <link rel="icon" type="image/png" sizes="16x16" href="logo/icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="logo/icon.png">
    <link rel="icon" type="image/png" sizes="48x48" href="logo/icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="logo/icon.png">
    <link rel="manifest" href="manifest.json">

    <meta name="theme-color" content="#1D222B">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Deep space background and sophisticated container */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Deep Navy/Black */
        }
        .container-card {
            background-color: #1d222b; /* Dark Gray-Blue */
            /* Enhanced box-shadow for a stronger, more defined outer glow */
            box-shadow: 0 0 50px rgba(16, 185, 129, 0.2), 0 0 15px rgba(16, 185, 129, 0.5); 
            border: 1px solid #34d39966; /* Subtle Emerald border */
        }
        /* New class for text glow on titles and important elements */
        .text-glow {
            text-shadow: 0 0 8px rgba(16, 185, 129, 0.7); /* Emerald glow */
        }
        
        /* Custom loader for the Emerald theme */
        #loader {
            border: 4px solid #374151; /* Dark Gray */
            border-top: 4px solid #10b981; /* Emerald 500 */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4 text-white">

    <div class="container-card w-full max-w-lg mx-auto rounded-xl p-8 shadow-2xl transition duration-300">
        <h1 class="text-4xl font-extrabold text-center text-emerald-400 mb-2 tracking-wide text-glow">
            Encryption3.0
        </h1>
        <p class="text-center text-md text-gray-400 mb-8">
            Uses <span class="text-emerald-300">AES-GCM</span> and <span class="text-emerald-300">PBKDF2</span> for military-grade security.
        </p>

        <!-- Main application area -->
        <div class="space-y-6">
            
            <!-- File input section -->
            <div>
                <label for="fileInput" class="block text-gray-300 font-medium mb-2">
                    Select a file:
                </label>
                <input type="file" id="fileInput"
                        class="block w-full text-sm text-gray-400 p-2 border border-gray-600 rounded-lg bg-gray-700 
                                file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0
                                file:text-sm file:font-semibold file:bg-emerald-600 file:text-white
                                hover:file:bg-emerald-700 cursor-pointer transition duration-200">
            </div>

            <!-- Key input section -->
            <div>
                <label for="keyInput" class="block text-gray-300 font-medium mb-2">
                    Enter your secret key:
                </label>
                <div class="relative">
                    <input type="password" id="keyInput" placeholder="Strong, memorable key..."
                            class="w-full p-3 pr-10 rounded-full bg-gray-700 text-white placeholder-gray-400
                                   focus:outline-none focus:ring-4 focus:ring-emerald-500/80 transition duration-150 border border-gray-600">
                    <button id="togglePassword" class="absolute inset-y-0 right-0 px-3 flex items-center text-gray-400 hover:text-emerald-400 transition"
                            aria-label="Toggle password visibility">
                         <!-- Eye Icon -->
                         <svg id="eye-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                        </svg>
                        <!-- Eye Off Icon -->
                        <svg id="eye-off-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.879 10.121A4.989 4.989 0 0112 15a4.989 4.989 0 01-1.879-4.879m3.758 3.758a.5.5 0 11-.707-.707m.707.707a.5.5 0 10-.707-.707" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m2-2l2-2" />
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Action buttons -->
            <div class="flex flex-col sm:flex-row gap-4 pt-4">
                <button id="encryptBtn"
                    class="w-full px-6 py-4 text-xl font-bold rounded-full shadow-lg 
                           bg-emerald-600 text-white hover:bg-emerald-700 transition duration-300 
                           transform hover:scale-[1.01] active:scale-95 hover:shadow-[0_0_15px_rgba(16,185,129,0.5)]">
                    Encrypt File
                </button>

                <button id="decryptBtn"
                    class="w-full px-6 py-4 text-xl font-bold rounded-full shadow-lg 
                           bg-gray-600 text-white hover:bg-gray-700 hover:shadow-[0_0_10px_rgba(16,185,129,0.3)] transition duration-300 
                           transform hover:scale-[1.01] active:scale-95">
                    Decrypt File
                </button>
            </div>

            <!-- Status and download area -->
            <div class="mt-8 text-center min-h-[100px] flex flex-col items-center justify-center space-y-4">
                <p id="statusMessage" class="text-base text-gray-300 min-h-[20px]"></p>
                <div id="loader" class="mx-auto hidden"></div>
                <a id="downloadLink" href="#" download 
                   class="hidden mt-4 inline-block px-8 py-3 text-lg font-bold rounded-full shadow-xl 
                          bg-emerald-500 hover:bg-emerald-600 text-white transition duration-300 hover:shadow-[0_0_15px_rgba(16,185,129,0.7)]">
                    Download File
                </a>
            </div>

            <!-- Disclaimer -->
            <div class="mt-8 pt-6 border-t border-gray-700 text-sm text-gray-500 text-center">
                <p>
                    <span class="font-bold text-emerald-400">Disclaimer:</span> This tool is client-side. Your key never leaves your browser.
                    For absolute maximum security, ensure your environment is clean and use a dedicated, unique key.
                </p>
            </div>
        </div>
        
        <!-- Footer moved and restyled to be inside the card -->
        <footer class="mt-8 pt-4 border-t border-gray-700 text-center text-sm text-gray-500">
            <p>Encryption Hub v1.0.1 - Licensed <a href="#" class="text-emerald-400 hover:underline">GPLv3</a> | Copyright Â© 2025</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const fileInput = document.getElementById('fileInput');
            const keyInput = document.getElementById('keyInput');
            const togglePasswordBtn = document.getElementById('togglePassword');
            const eyeIcon = document.getElementById('eye-icon');
            const eyeOffIcon = document.getElementById('eye-off-icon');
            const encryptBtn = document.getElementById('encryptBtn');
            const decryptBtn = document.getElementById('decryptBtn');
            const statusMessage = document.getElementById('statusMessage');
            const downloadLink = document.getElementById('downloadLink');
            const loader = document.getElementById('loader');

            // NOTE: The iterations are set very high (10 million) for cryptographic strength.
            // This WILL cause a noticeable browser freeze during key derivation.
            const iterations = 10000000;
            const keyLength = 256;
            let originalFile = null;

            // Toggle password visibility
            togglePasswordBtn.addEventListener('click', (e) => {
                e.preventDefault(); // Prevent button from submitting a form if it were in one
                const type = keyInput.getAttribute('type') === 'password' ? 'text' : 'password';
                keyInput.setAttribute('type', type);
                eyeIcon.classList.toggle('hidden');
                eyeOffIcon.classList.toggle('hidden');
            });


            // Function to handle the selected file
            fileInput.addEventListener('change', (event) => {
                originalFile = event.target.files[0];
                if (originalFile) {
                    statusMessage.textContent = `File selected: ${originalFile.name}`;
                    downloadLink.classList.add('hidden');
                } else {
                    statusMessage.textContent = 'No file selected.';
                }
            });

            // Function to set the UI state
            function setUIState(isProcessing) {
                encryptBtn.disabled = isProcessing;
                decryptBtn.disabled = isProcessing;
                fileInput.disabled = isProcessing;
                keyInput.disabled = isProcessing;
                
                if (isProcessing) {
                    encryptBtn.classList.add('opacity-50');
                    decryptBtn.classList.add('opacity-50');
                    loader.classList.remove('hidden');
                    downloadLink.classList.add('hidden');
                } else {
                    encryptBtn.classList.remove('opacity-50');
                    decryptBtn.classList.remove('opacity-50');
                    loader.classList.add('hidden');
                }
            }
            
            // Function to derive a key from a password using PBKDF2
            async function deriveKeyFromPassword(password, salt, keyUsage) {
                const passwordBuffer = new TextEncoder().encode(password);
                const baseKey = await crypto.subtle.importKey(
                    "raw",
                    passwordBuffer,
                    { name: "PBKDF2" },
                    false,
                    ["deriveKey"]
                );

                return await crypto.subtle.deriveKey(
                    {
                        name: "PBKDF2",
                        salt: salt,
                        iterations: iterations,
                        hash: "SHA-256",
                    },
                    baseKey,
                    { name: "AES-GCM", length: keyLength },
                    false,
                    keyUsage
                );
            }

            // Handle Encrypt button click
            encryptBtn.addEventListener('click', async () => {
                if (!originalFile) {
                    statusMessage.textContent = "Please select a file first.";
                    return;
                }
                if (!keyInput.value) {
                    statusMessage.textContent = "Please enter a key.";
                    return;
                }

                setUIState(true);
                
                try {
                    // STEP 1/3: Reading file
                    statusMessage.textContent = "STEP 1/3: Reading file into memory...";
                    const fileBuffer = await originalFile.arrayBuffer();

                    // STEP 2/3: Key Derivation (CPU intensive)
                    statusMessage.textContent = `STEP 2/3: Deriving key with PBKDF2 (${iterations/1000000}M rounds - CPU intensive)...`;
                    
                    const salt = crypto.getRandomValues(new Uint8Array(16));
                    const iv = crypto.getRandomValues(new Uint8Array(12));
                    
                    const derivedKey = await deriveKeyFromPassword(keyInput.value, salt, ["encrypt"]);

                    // STEP 3/3: Encryption
                    statusMessage.textContent = "STEP 3/3: Performing AES-GCM encryption...";

                    // Encrypt the file buffer
                    const encryptedBuffer = await crypto.subtle.encrypt(
                        { name: "AES-GCM", iv: iv },
                        derivedKey,
                        fileBuffer
                    );

                    // --- Finalizing and combining data ---
                    const fileNameBuffer = new TextEncoder().encode(originalFile.name);
                    if (fileNameBuffer.byteLength > 255) {
                        statusMessage.textContent = "Filename is too long.";
                        setUIState(false);
                        return;
                    }
                    const fileNameLength = new Uint8Array([fileNameBuffer.byteLength]);

                    // Combine filename length (1 byte), filename, salt (16 bytes), iv (12 bytes), and encrypted data
                    const combined = new Uint8Array(1 + fileNameBuffer.byteLength + salt.length + iv.length + encryptedBuffer.byteLength);
                    let offset = 0;
                    combined.set(fileNameLength, offset); offset += 1;
                    combined.set(fileNameBuffer, offset); offset += fileNameBuffer.byteLength;
                    combined.set(salt, offset); offset += salt.length;
                    combined.set(iv, offset); offset += iv.length;
                    combined.set(new Uint8Array(encryptedBuffer), offset);
                    
                    const encryptedBlob = new Blob([combined], { type: 'application/octet-stream' });
                    
                    const newFileName = originalFile.name + '.enc';

                    const url = URL.createObjectURL(encryptedBlob);
                    downloadLink.href = url;
                    downloadLink.download = newFileName;
                    downloadLink.textContent = `Download Encrypted File (${newFileName})`;
                    downloadLink.classList.remove('hidden');
                    
                    downloadLink.addEventListener('click', () => {
                        setTimeout(() => URL.revokeObjectURL(url), 500);
                    }, { once: true });

                    statusMessage.textContent = "Encryption complete! Download your file.";
                    setUIState(false);

                } catch (error) {
                    statusMessage.textContent = `Encryption failed: ${error.message}`;
                    console.error("Encryption Error:", error);
                    setUIState(false);
                }
            });

            // Handle Decrypt button click
            decryptBtn.addEventListener('click', async () => {
                if (!originalFile) {
                    statusMessage.textContent = "Please select a file first.";
                    return;
                }
                if (!keyInput.value) {
                    statusMessage.textContent = "Please enter a key.";
                    return;
                }

                setUIState(true);

                try {
                    // STEP 1/3: Reading encrypted file
                    statusMessage.textContent = "STEP 1/3: Reading encrypted file header and payload...";

                    const encryptedFileBuffer = await originalFile.arrayBuffer();
                    
                    const MIN_HEADER_SIZE = 1 + 1 + 16 + 12; // Length(1) + Min Filename(1) + Salt(16) + IV(12)
                    if (encryptedFileBuffer.byteLength < MIN_HEADER_SIZE) { 
                        throw new Error("File is too small or corrupted.");
                    }

                    // --- EXTRACT METADATA ---
                    let offset = 0;
                    const headerArray = new Uint8Array(encryptedFileBuffer);

                    // 1. Filename Length (1 byte)
                    const fileNameLength = headerArray[offset]; offset += 1;
                    if (fileNameLength === 0) throw new Error("Filename metadata is missing.");

                    // 2. Filename Buffer
                    const fileNameBuffer = headerArray.slice(offset, offset + fileNameLength); offset += fileNameLength;
                    const newFileName = new TextDecoder().decode(fileNameBuffer);
                    
                    // 3. Salt (16 bytes)
                    const salt = headerArray.slice(offset, offset + 16); offset += 16;
                    
                    // 4. IV (12 bytes)
                    const iv = headerArray.slice(offset, offset + 12); offset += 12;
                    
                    // 5. Encrypted Data (rest of the file)
                    const encryptedData = headerArray.slice(offset);
                    
                    if (encryptedData.byteLength === 0) throw new Error("Encrypted data is missing or zero length.");

                    // STEP 2/3: Key Derivation (CPU intensive)
                    statusMessage.textContent = `STEP 2/3: Deriving key with PBKDF2 (${iterations/1000000}M rounds - CPU intensive)...`;

                    const derivedKey = await deriveKeyFromPassword(keyInput.value, salt, ["decrypt"]);

                    // STEP 3/3: Decryption
                    statusMessage.textContent = "STEP 3/3: Performing AES-GCM decryption...";

                    // Decrypt the data
                    const decryptedBuffer = await crypto.subtle.decrypt(
                        { name: "AES-GCM", iv: iv },
                        derivedKey,
                        encryptedData
                    );

                    const decryptedBlob = new Blob([decryptedBuffer], { type: 'application/octet-stream' });
                    
                    const finalFileName = newFileName.endsWith('.enc') ? newFileName.slice(0, -4) : newFileName;

                    const url = URL.createObjectURL(decryptedBlob);
                    downloadLink.href = url;
                    downloadLink.download = finalFileName;
                    downloadLink.textContent = `Download Decrypted File (${finalFileName})`;
                    downloadLink.classList.remove('hidden');

                    downloadLink.addEventListener('click', () => {
                        setTimeout(() => URL.revokeObjectURL(url), 500);
                    }, { once: true });

                    statusMessage.textContent = "Decryption complete! Download your file.";
                    setUIState(false);

                } catch (error) {
                    if (error.name === 'OperationError') {
                        statusMessage.textContent = "Decryption failed. The secret key is incorrect or the file was corrupted.";
                    } else {
                        statusMessage.textContent = `Decryption failed. Error: ${error.message}`;
                    }
                    console.error("Decryption Error:", error);
                    setUIState(false);
                }
            });
        });
    </script>
</body>
</html>
