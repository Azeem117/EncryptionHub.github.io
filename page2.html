<!--
    Encryption Hub
    Copyright (C) 2024  MD AZEEM

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Encryption2.0</title>
    <!-- Inter font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Crypto-JS for AES encryption -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        :root {
            --color-primary: #0a0a0a;
            --color-secondary: #181818;
            --color-accent: #6C1E9D;
            --color-accent-light: #8A2BE2;
            --color-accent-dark: #4A147D;
            --color-text: #E0E0E0;
            --color-text-subtle: #A3A3A3;
        }
        body {
            background-image: linear-gradient(135deg, #100C1C 0%, #1A1A1A 100%);
            font-family: 'Inter', sans-serif;
        }
        .container {
            background-color: var(--color-secondary);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid var(--color-accent-dark);
        }
        .logo-svg {
            fill: var(--color-accent);
        }
        .password-toggle svg path {
            transition: stroke 0.2s;
        }
        .password-toggle:hover svg path {
            stroke: var(--color-text);
        }
        .btn {
            background: linear-gradient(to right, var(--color-accent-light), var(--color-accent));
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: background 0.3s, transform 0.2s, box-shadow 0.3s;
        }
        .btn:hover {
            background: linear-gradient(to right, var(--color-accent-dark), var(--color-accent-light));
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(138, 43, 226, 0.5);
        }
        .progress-bar {
            background: linear-gradient(to right, var(--color-accent-dark), var(--color-accent-light));
            transition: width 0.3s ease;
        }
        #download-link {
            background: linear-gradient(to right, var(--color-accent-light), var(--color-accent));
            box-shadow: 0 5px 15px rgba(138, 43, 226, 0.3);
            transition: background 0.3s, transform 0.2s;
        }
        #download-link:hover {
            background: linear-gradient(to right, var(--color-accent-dark), var(--color-accent-light));
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(138, 43, 226, 0.5);
        }
        .modal {
            background-color: rgba(0,0,0,0.7);
        }
        .modal-content {
            background-color: var(--color-secondary);
            box-shadow: 0 5px 25px rgba(0,0,0,0.5);
        }
        .modal-close-btn {
            background: linear-gradient(to right, var(--color-accent), var(--color-accent-dark));
        }
        .modal-close-btn:hover {
            background: linear-gradient(to right, var(--color-accent-dark), var(--color-accent));
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex flex-col justify-center items-center min-h-screen p-4">
    <div class="container rounded-2xl p-8 w-full max-w-2xl text-center">
        <div class="logo mb-5">
            <svg class="logo-svg mx-auto w-20 h-20" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <mask id="hood-mask">
                        <rect width="100" height="100" fill="white" />
                        <circle cx="50" cy="50" r="30" fill="black" />
                    </mask>
                </defs>
                <path d="M50 20 C 20 20, 20 80, 50 80 C 80 80, 80 20, 50 20 Z" fill="var(--color-accent-light)" mask="url(#hood-mask)"/>
                <path d="M50 20 C 40 10, 30 15, 30 25 L 30 40 C 30 50, 40 60, 50 60 C 60 60, 70 50, 70 40 L 70 25 C 70 15, 60 10, 50 20 Z" fill="var(--color-secondary)"/>
            </svg>
        </div>
        <h1 class="text-4xl font-extrabold text-purple-400 -mt-2 mb-1">Encryption2.0</h1>
        <p class="text-gray-400 text-lg mb-8">Securely hide secret messages within images.</p>

        <div class="mb-6 text-left">
            <label for="image-input" class="block mb-2 font-semibold text-gray-200">Upload an Image</label>
            <input type="file" id="image-input" accept="image/*" class="block w-full text-sm text-gray-500
                file:mr-4 file:py-2 file:px-4
                file:rounded-md file:border-0
                file:text-sm file:font-semibold
                file:bg-purple-600 file:text-white
                hover:file:bg-purple-700
                border border-gray-700 rounded-md bg-gray-800">
        </div>

        <div class="mb-6 text-left">
            <label for="message-input" class="block mb-2 font-semibold text-gray-200">Secret Message</label>
            <textarea id="message-input" placeholder="Enter your secret message here..."
                      class="w-full h-32 p-3 bg-gray-800 border-2 border-gray-700 rounded-lg text-gray-200 resize-y focus:outline-none focus:ring-2 focus:ring-purple-500 transition-colors"></textarea>
        </div>

        <div class="relative mb-6 text-left">
            <div class="flex justify-between items-center mb-2">
                <label for="password-input" class="font-semibold text-gray-200">Password</label>
                <span class="password-toggle cursor-pointer text-gray-400 hover:text-gray-200" id="password-toggle-icon">
                    <svg class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                        <path d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                    </svg>
                </span>
            </div>
            <input type="password" id="password-input" placeholder="Enter a password to encrypt/decrypt"
                   class="w-full p-3 bg-gray-800 border-2 border-gray-700 rounded-lg text-gray-200 focus:outline-none focus:ring-2 focus:ring-purple-500 transition-colors">
        </div>

        <div class="flex flex-col sm:flex-row gap-4 mt-8">
            <button class="btn flex-1 min-w-[150px] p-4 rounded-lg text-lg font-bold text-white relative flex items-center justify-center" id="hide-btn">
                Encrypt
            </button>
            <button class="btn flex-1 min-w-[150px] p-4 rounded-lg text-lg font-bold text-white relative flex items-center justify-center" id="reveal-btn">
                Decrypt
            </button>
        </div>

        <div class="w-full h-2 bg-gray-800 rounded-md my-6 shadow-inner">
            <div id="progress-bar" class="h-full rounded-md" style="width: 0;"></div>
        </div>

        <p id="status-message" class="font-semibold text-purple-400 min-h-[20px] text-sm mb-4"></p>

        <a href="#" id="download-link" download="cloaked_image.png" class="hidden inline-block px-8 py-3 rounded-lg font-bold text-white">
            Download Image
        </a>
    </div>

    <canvas id="canvas" class="hidden"></canvas>

    <div id="modal" class="modal fixed inset-0 flex justify-center items-center z-50 hidden">
        <div class="modal-content rounded-xl p-8 w-11/12 max-w-md text-center">
            <p class="modal-message text-lg mb-6" id="modal-message-text"></p>
            <button class="modal-close-btn py-2 px-6 rounded-lg font-semibold text-white" onclick="closeModal()">OK</button>
        </div>
    </div>

    <script>
        // --- UI Element References ---
        const imageInput = document.getElementById('image-input');
        const messageInput = document.getElementById('message-input');
        const passwordInput = document.getElementById('password-input');
        const passwordToggle = document.getElementById('password-toggle-icon');
        const hideBtn = document.getElementById('hide-btn');
        const revealBtn = document.getElementById('reveal-btn');
        const progressBar = document.getElementById('progress-bar');
        const statusMessage = document.getElementById('status-message');
        const downloadLink = document.getElementById('download-link');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const modal = document.getElementById('modal');
        const modalMessageText = document.getElementById('modal-message-text');

        // The number of pixel channels to process per animation frame
        // Higher values mean faster processing but potentially less responsive UI
        const CHANNELS_PER_CHUNK = 50000;

        // --- Helper Functions ---

        /**
         * Shows a modal with a given message.
         * @param {string} message The message to display in the modal.
         */
        function showModal(message) {
            modalMessageText.textContent = message;
            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        /**
         * Closes the currently open modal.
         */
        function closeModal() {
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        }

        /**
         * Updates the UI to show a loading state for the specified button.
         * @param {HTMLElement} btn The button element to update.
         * @param {string} text The text to show on the button.
         * @param {boolean} isLoading Whether the button is in a loading state.
         */
        function showLoading(btn, text, isLoading) {
            btn.innerHTML = isLoading ? `<div class="spinner"></div>` : text;
            btn.disabled = isLoading;
            btn.classList.toggle('opacity-50', isLoading);
            btn.classList.toggle('cursor-not-allowed', isLoading);
        }

        /**
         * Shows a status message to the user and updates the UI.
         * @param {string} message The message to display.
         * @param {string} color The color of the message (Tailwind class).
         */
        function showStatus(message, color = 'text-purple-400') {
            statusMessage.textContent = message;
            statusMessage.className = `font-semibold min-h-[20px] text-sm mb-4 ${color}`;
        }

        /**
         * Resets the UI to its initial state.
         */
        function resetUI() {
            messageInput.value = '';
            passwordInput.value = '';
            statusMessage.textContent = '';
            progressBar.style.width = '0%';
            downloadLink.classList.add('hidden');
            showLoading(hideBtn, 'Encrypt', false);
            showLoading(revealBtn, 'Decrypt', false);
        }
        
        // --- Main Steganography Logic (Asynchronous) ---

        /**
         * Hides a message in an image asynchronously.
         * @param {Uint8ClampedArray} data The image pixel data.
         * @param {string} binarySecret The binary string of the secret message.
         * @param {number} totalBits The total number of bits to hide.
         * @param {number} startIndex The starting index for processing.
         * @param {function} onComplete Callback function to execute on completion.
         */
        function hideMessageAsync(data, binarySecret, totalBits, startIndex, onComplete) {
            let i = startIndex;
            const end = Math.min(startIndex + CHANNELS_PER_CHUNK, totalBits);

            const hideStep = () => {
                for (; i < end; i++) {
                    const pixelIndex = Math.floor(i / 3) * 4;
                    const channelIndex = i % 3;
                    const value = data[pixelIndex + channelIndex];
                    const secretBit = parseInt(binarySecret[i], 2);

                    data[pixelIndex + channelIndex] = (value & ~1) | secretBit;
                }

                updateProgress((i / totalBits) * 100);

                if (i < totalBits) {
                    requestAnimationFrame(() => hideMessageAsync(data, binarySecret, totalBits, i, onComplete));
                } else {
                    onComplete();
                }
            };
            requestAnimationFrame(hideStep);
        }

        /**
         * Reveals a message from an image asynchronously.
         * @param {Uint8ClampedArray} data The image pixel data.
         * @param {function} onComplete Callback function with the extracted binary string.
         */
        function revealMessageAsync(data, onComplete) {
            let i = 0;
            let binarySecret = '';
            let isComplete = false;

            const revealStep = () => {
                const end = Math.min(i + CHANNELS_PER_CHUNK, data.length);
                let secretMessage = '';

                for (; i < end && !isComplete; i += 4) {
                    binarySecret += (data[i] & 1).toString();
                    binarySecret += (data[i + 1] & 1).toString();
                    binarySecret += (data[i + 2] & 1).toString();
                    
                    if (binarySecret.length % 8 === 0) {
                        secretMessage = fromBinary(binarySecret);
                        if (secretMessage.includes('###END_OF_MESSAGE###')) {
                            isComplete = true;
                            break;
                        }
                    }
                }

                updateProgress((i / data.length) * 100);
                
                if (isComplete) {
                    onComplete(binarySecret);
                } else if (i < data.length) {
                    requestAnimationFrame(revealStep);
                } else {
                    onComplete(''); // No message found
                }
            };
            requestAnimationFrame(revealStep);
        }

        // --- Event Listeners ---

        hideBtn.addEventListener('click', async () => {
            const imageFile = imageInput.files[0];
            const message = messageInput.value;
            const password = passwordInput.value;
            
            if (!imageFile || !message || !password) {
                showModal('Please upload an image, type a message, and enter a password to hide.');
                return;
            }

            showLoading(hideBtn, 'Hiding...', true);
            showStatus('Preparing image...');
            downloadLink.classList.add('hidden');
            
            try {
                const reader = new FileReader();
                reader.readAsDataURL(imageFile);
                reader.onloadend = async () => {
                    const img = new Image();
                    img.onload = async () => {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);

                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        
                        showStatus('Encrypting message...');
                        const encryptedMessage = CryptoJS.AES.encrypt(message, password).toString();
                        
                        const secretData = encryptedMessage + '###END_OF_MESSAGE###';
                        const binarySecret = toBinary(secretData);
                        
                        const availableSpace = (data.length / 4) * 3;
                        if (binarySecret.length > availableSpace) {
                             showModal('Message is too long for this image. Please use a larger image or a shorter message.');
                             showLoading(hideBtn, 'Encrypt', false);
                             return;
                        }

                        showStatus('Hiding message in pixels...');
                        hideMessageAsync(data, binarySecret, binarySecret.length, 0, () => {
                            ctx.putImageData(imageData, 0, 0);
                            const newImageUrl = canvas.toDataURL('image/png');
                            downloadLink.href = newImageUrl;
                            downloadLink.classList.remove('hidden');
                            
                            showStatus('Message hidden! Click the link below to download.', 'text-green-500');
                            updateProgress(100);
                            showLoading(hideBtn, 'Encrypt', false);
                        });
                    };
                    img.src = reader.result;
                };
            } catch (error) {
                showStatus('An error occurred during hiding. Please try again.', 'text-red-500');
                showLoading(hideBtn, 'Encrypt', false);
                console.error(error);
            }
        });

        revealBtn.addEventListener('click', async () => {
            const imageFile = imageInput.files[0];
            const password = passwordInput.value;
            
            if (!imageFile || !password) {
                showModal('Please upload a steganographic image and enter a password to reveal.');
                return;
            }
            
            showLoading(revealBtn, 'Revealing...', true);
            showStatus('Loading image and revealing message...');
            
            try {
                const reader = new FileReader();
                reader.readAsDataURL(imageFile);
                reader.onloadend = () => {
                    const img = new Image();
                    img.onload = () => {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
        
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        
                        showStatus('Extracting message from pixels...');
                        revealMessageAsync(data, (binarySecret) => {
                            if (!binarySecret) {
                                showModal('No hidden message found or the image is corrupted.');
                                showStatus('No hidden message found.', 'text-red-500');
                                showLoading(revealBtn, 'Decrypt', false);
                                return;
                            }
                            
                            const secretMessageWithSeparator = fromBinary(binarySecret);
                            const [secretMessage, separator] = secretMessageWithSeparator.split('###END_OF_MESSAGE###');
                            
                            if (separator === undefined) {
                                showModal('Could not find the end of the message. The image may be corrupted.');
                                showStatus('Extraction failed.', 'text-red-500');
                                showLoading(revealBtn, 'Decrypt', false);
                                return;
                            }

                            showStatus('Decrypting message...');
                            try {
                                const decryptedBytes = CryptoJS.AES.decrypt(secretMessage, password);
                                const decryptedMessage = decryptedBytes.toString(CryptoJS.enc.Utf8);
                                
                                if (decryptedMessage) {
                                    messageInput.value = decryptedMessage;
                                    showStatus('Message revealed successfully!', 'text-green-500');
                                } else {
                                    showModal('Could not decrypt the message. The password may be incorrect.');
                                    showStatus('Decryption failed. Invalid password.', 'text-red-500');
                                }
                            } catch (e) {
                                showModal('Could not decrypt the message. The password may be incorrect or the data is invalid.');
                                showStatus('Decryption failed.', 'text-red-500');
                            }
                            updateProgress(100);
                            showLoading(revealBtn, 'Decrypt', false);
                        });
                    };
                    img.src = reader.result;
                };
            } catch (error) {
                showStatus('An error occurred during revealing. Please try again.', 'text-red-500');
                showLoading(revealBtn, 'Decrypt', false);
                console.error(error);
            }
        });

        // --- Helper Functions for Data Conversion ---

        function toBinary(str) {
            return str.split('').map(char => char.charCodeAt(0).toString(2).padStart(8, '0')).join('');
        }

        function fromBinary(bin) {
            const bytes = [];
            for (let i = 0; i < bin.length; i += 8) {
                bytes.push(parseInt(bin.substring(i, i + 8), 2));
            }
            return String.fromCharCode(...bytes);
        }

        function updateProgress(progress) {
            progressBar.style.width = `${progress}%`;
        }

        // --- UI Interactions ---
        passwordToggle.addEventListener('click', () => {
            const isPassword = passwordInput.type === 'password';
            passwordInput.type = isPassword ? 'text' : 'password';
            const iconPath = isPassword ? 
                `<svg class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.09 9.09 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19M1 1l22 22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/><circle cx="12" cy="12" r="3" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/></svg>` : 
                `<svg class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>`;
            passwordToggle.innerHTML = iconPath;
        });

        imageInput.addEventListener('change', resetUI);
    </script>

    <footer class="py-6 text-center text-sm text-gray-400">
        <p>MD AZEEM &copy; 2025 All Rights Reserved.</p>
    </footer>
</body>
</html>
