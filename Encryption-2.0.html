<!--
==============================================================================
Encryption Hub – Secure Message, File, and Steganography Application
==============================================================================

Project: Encryption Hub
Version: 1.0.3
Author: MD AZEEM
Website: https://github.com/Azeem117
Release Date: 2025
Modules: Encryption 1.0 → 5.0 (Text, Steganography, File, PDF, Strong Password Generation)

============================================================================== 
License: GNU General Public License v3.0 (GPL-3.0)
==============================================================================

This software is free to use, modify, and redistribute under the terms of the 
GNU GPL v3.0. There is **no warranty** of any kind, express or implied, 
including merchantability or fitness for a particular purpose. 

Full License: https://www.gnu.org/licenses/gpl-3.0.en.html

============================================================================== 
Third-Party Components
==============================================================================

1. PDF Generation & Handling:
   - pdfmake: https://pdfmake.github.io/docs/ (MIT License)
     Used for: Password-protected PDFs with encrypted payloads
   - PDF.js: https://mozilla.github.io/pdf.js/ (Apache 2.0 License)
     Used for: Reading PDFs and extracting embedded payloads

2. Styling & Typography:
   - Tailwind CSS: https://tailwindcss.com/ (MIT License)
   - Inter Font: https://fonts.google.com/specimen/Inter (SIL Open Font License 1.1)

3. Cryptography & Security:
   - Web Crypto API (Browser Built-in)
     Used for: AES-GCM encryption, PBKDF2 key derivation, strong password generation
   - Custom LSB Steganography (GPL-3.0)
     Used for: Hiding encrypted messages in images

============================================================================== 
Feature Highlights
==============================================================================

- AES-GCM encryption with PBKDF2 key derivation
- LSB steganography in PNG/JPG images
- File encryption for text, images, audio, video, and documents
- Password-protected PDF generation with embedded encrypted payloads
- Weak-to-strong password generation (PBKDF2, up to 10,000,000 iterations)
- Responsive, modern UI with progress feedback and error handling

============================================================================== 
License & Compliance Notes
==============================================================================

- MIT Components (Tailwind CSS, pdfmake): Include copyright notices and preserve license text.
- Apache 2.0 Components (PDF.js): Preserve copyright, include license, document changes, provide attribution.
- SIL Open Font License (Inter Font): Preserve license and copyright; font name not used for derivatives.
- GPL-3.0 Components (This Project): Source code availability, document changes, maintain same license, preserve copyright.

============================================================================== 
Security Notice
==============================================================================

All encryption and steganography operations occur **client-side**. 
No data is transmitted to any server. Processing uses standard Web APIs 
in the browser to ensure maximum privacy.

Report security issues: adwardcollin365@gmail.com
==============================================================================
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Encryption2.0</title>
     <link rel="icon" type="image/png" sizes="16x16" href="logo/icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="logo/icon.png">
    <link rel="icon" type="image/png" sizes="48x48" href="logo/icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="logo/icon.png">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#000000">

    <!-- Inter font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Removed Crypto-JS: Now using native Web Crypto API -->
    <style>
        /* NEW DEEP BLACK & ELECTRIC MAGENTA THEME */
        :root {
            --color-primary: #000000; /* Pure Black for body background base */
            --color-secondary: #0D0D0D; /* Near Black for containers/inputs */
            --color-accent: #E879F9; /* ELECTRIC MAGENTA (Fuchsia-400) */
            --color-accent-light: #F0ABFC; /* Lighter Magenta for hover/spinner/glow */
            --color-accent-dark: #C026D3; /* Deep Magenta/Fuchsia-700 for borders */
            --color-text: #F3F4F6; /* Near White */
            --color-text-subtle: #4B5563; /* Dark Gray for subtle text */
        }
        body {
            /* Pure Black background, removing gradient */
            background-color: var(--color-primary);
            background-image: none;
            font-family: 'Inter', sans-serif;
            color: var(--color-text);
        }
        .container {
            background-color: var(--color-secondary);
            /* Subtle magenta glow shadow */
            box-shadow: 0 10px 30px rgba(232, 121, 249, 0.3);
            border: 1px solid var(--color-accent-dark); /* Border uses dark accent */
        }
        .logo-svg {
            fill: var(--color-accent);
        }
        /* Style for the main title glow effect (Now CYBER Glow) */
        .cyber-glow {
            color: var(--color-accent);
            text-shadow: 0 0 5px var(--color-accent), 0 0 15px var(--color-accent-light), 0 0 30px rgba(240, 171, 252, 0.8);
        }
        .password-toggle svg path {
            transition: stroke 0.2s;
            stroke: var(--color-text-subtle);
        }
        .password-toggle:hover svg path {
            stroke: var(--color-accent-light);
        }
        .btn {
            /* Neon Magenta gradient for main buttons */
            background: linear-gradient(to right, var(--color-accent-light), var(--color-accent));
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: background 0.3s, transform 0.2s, box-shadow 0.3s;
            color: var(--color-secondary); /* Dark text for contrast */
        }
        .btn:hover {
            /* Hover gradient */
            background: linear-gradient(to right, var(--color-accent-dark), var(--color-accent-light));
            transform: translateY(-3px);
            /* Stronger glow on hover (Magenta glow) */
            box-shadow: 0 8px 25px rgba(240, 171, 252, 0.9);
        }
        .progress-bar {
            background: linear-gradient(to right, var(--color-accent-dark), var(--color-accent));
            transition: width 0.3s ease;
        }
        #download-link {
            /* Neon Magenta gradient for download link */
            background: linear-gradient(to right, var(--color-accent-light), var(--color-accent));
            box-shadow: 0 5px 15px rgba(232, 121, 249, 0.3);
            transition: background 0.3s, transform 0.2s;
            color: var(--color-secondary);
        }
        #download-link:hover {
            /* Hover gradient and stronger glow */
            background: linear-gradient(to right, var(--color-accent-dark), var(--color-accent-light));
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(240, 171, 252, 0.9);
        }
        .modal {
            background-color: rgba(0,0,0,0.8);
        }
        .modal-content {
            background-color: var(--color-secondary);
            box-shadow: 0 5px 25px rgba(0,0,0,0.5);
        }
        .modal-close-btn {
            /* Close button uses accent dark/normal */
            background: linear-gradient(to right, var(--color-accent), var(--color-accent-dark));
            color: var(--color-text);
        }
        .modal-close-btn:hover {
            background: linear-gradient(to right, var(--color-accent-dark), var(--color-accent));
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid var(--color-accent-light); /* Spinner uses light accent */
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Back to Home Button */
        .back-btn {
            position: fixed;
            top: 1rem;
            left: 1rem;
            background-color: var(--color-accent);
            color: #000000;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s, box-shadow 0.2s;
            border: none;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 4px 12px rgba(232, 121, 249, 0.4);
            z-index: 1000;
        }
        .back-btn:hover {
            background-color: var(--color-accent-light);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(232, 121, 249, 0.6);
        }
        .back-btn svg {
            width: 1.25rem;
            height: 1.25rem;
        }
    </style>
</head>
<body class="flex flex-col justify-center items-center min-h-screen p-4 text-gray-50">

<!-- Back to Home Button -->
<a href="index.html" class="back-btn" title="Back to Home">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
        <path fill-rule="evenodd" d="M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z" clip-rule="evenodd" />
    </svg>
    Home
</a>

    <div class="container rounded-2xl p-8 w-full max-w-2xl text-center">
        <div class="logo mb-5">
            <svg class="logo-svg mx-auto w-20 h-20" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <mask id="hood-mask">
                        <rect width="100" height="100" fill="white" />
                        <circle cx="50" cy="50" r="30" fill="black" />
                    </mask>
                </defs>
                <path d="M50 20 C 20 20, 20 80, 50 80 C 80 80, 80 20, 50 20 Z" fill="var(--color-accent-light)" mask="url(#hood-mask)"/>
                <path d="M50 20 C 40 10, 30 15, 30 25 L 30 40 C 30 50, 40 60, 50 60 C 60 60, 70 50, 70 40 L 70 25 C 70 15, 60 10, 50 20 Z" fill="var(--color-secondary)"/>
            </svg>
        </div>
        <!-- Applied new cyber-glow class for the title -->
        <h1 class="text-4xl font-extrabold cyber-glow -mt-2 mb-1">Encryption2.0</h1>
        <!-- Updated subtle text color -->
        <p class="text-gray-400 text-lg mb-8">Securely hide secret messages within images.</p>

        <div class="mb-6 text-left">
            <label for="image-input" class="block mb-2 font-semibold text-gray-200">Upload an Image</label>
            <input type="file" id="image-input" accept="image/*" class="block w-full text-sm text-gray-400
                file:mr-4 file:py-2 file:px-4
                file:rounded-md file:border-0
                file:text-sm file:font-semibold
                file:bg-[#701a75] file:text-white
                hover:file:bg-[#86198f]
                border border-gray-700 rounded-md bg-gray-800">
        </div>

        <div class="mb-6 text-left">
            <label for="message-input" class="block mb-2 font-semibold text-gray-200">Secret Message</label>
            <textarea id="message-input" placeholder="Enter your secret message here..."
                      class="w-full h-32 p-3 bg-gray-800 border-2 border-gray-700 rounded-lg text-gray-200 resize-y focus:outline-none focus:ring-2 focus:ring-[#E879F9] transition-colors"></textarea>
        </div>

        <div class="relative mb-6 text-left">
            <div class="flex justify-between items-center mb-2">
                <label for="password-input" class="font-semibold text-gray-200">Password</label>
                <span class="password-toggle cursor-pointer text-gray-400 hover:text-gray-200" id="password-toggle-icon">
                    <svg class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                        <path d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                    </svg>
                </span>
            </div>
            <input type="password" id="password-input" placeholder="Enter a password to encrypt/decrypt"
                   class="w-full p-3 bg-gray-800 border-2 border-gray-700 rounded-lg text-gray-200 focus:outline-none focus:ring-2 focus:ring-[#E879F9] transition-colors">
        </div>

        <div class="flex flex-col sm:flex-row gap-4 mt-8">
            <button class="btn flex-1 min-w-[150px] p-4 rounded-lg text-lg font-bold relative flex items-center justify-center" id="hide-btn">
                Encrypt
            </button>
            <button class="btn flex-1 min-w-[150px] p-4 rounded-lg text-lg font-bold relative flex items-center justify-center" id="reveal-btn">
                Decrypt
            </button>
        </div>

        <div class="w-full h-2 bg-gray-800 rounded-md my-6 shadow-inner">
            <div id="progress-bar" class="h-full rounded-md" style="width: 0;"></div>
        </div>

        <!-- Updated status color default to magenta-400 -->
        <p id="status-message" class="font-semibold text-[#E879F9] min-h-[20px] text-sm mb-4"></p>

        <a href="#" id="download-link" download="cloaked_image.png" class="hidden inline-block px-8 py-3 rounded-lg font-bold">
            Download Image
        </a>
    </div>

    <canvas id="canvas" class="hidden"></canvas>

    <div id="modal" class="modal fixed inset-0 flex justify-center items-center z-50 hidden">
        <div class="modal-content rounded-xl p-8 w-11/12 max-w-md text-center">
            <p class="modal-message text-lg mb-6" id="modal-message-text"></p>
            <button class="modal-close-btn py-2 px-6 rounded-lg font-semibold" onclick="closeModal()">OK</button>
        </div>
    </div>

    <script>
        // --- UI Element References ---
        const imageInput = document.getElementById('image-input');
        const messageInput = document.getElementById('message-input');
        const passwordInput = document.getElementById('password-input');
        const passwordToggle = document.getElementById('password-toggle-icon');
        const hideBtn = document.getElementById('hide-btn');
        const revealBtn = document.getElementById('reveal-btn');
        const progressBar = document.getElementById('progress-bar');
        const statusMessage = document.getElementById('status-message');
        const downloadLink = document.getElementById('download-link');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const modal = document.getElementById('modal');
        const modalMessageText = document.getElementById('modal-message-text');

        // The number of pixel channels to process per animation frame
        const CHANNELS_PER_CHUNK = 50000;

        // --- Helper Functions for Cryptography ---

        // Converts a string to a Uint8Array.
        function strToUint8(str) {
            return new TextEncoder().encode(str);
        }

        // Converts a Uint8Array to a string.
        function uint8ToStr(uint8) {
            return new TextDecoder().decode(uint8);
        }

        // Converts an ArrayBuffer to a Base64 string.
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        // Converts a Base64 string to an ArrayBuffer.
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // --- Core Cryptographic Functions (Web Crypto API) ---

        /**
         * Derives a cryptographic key using PBKDF2 with 1,000,000 iterations.
         * @param {string} password User password string.
         * @param {ArrayBuffer} salt 16-byte random salt.
         * @returns {Promise<CryptoKey>} The derived AES-GCM 256-bit key.
         */
        async function getKey(password, salt) {
            const keyMaterial = await window.crypto.subtle.importKey(
                "raw",
                strToUint8(password),
                { name: "PBKDF2" },
                false,
                ["deriveKey"]
            );
            return window.crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 1000000, // 1 million iterations
                    hash: "SHA-256",
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );
        }

        /**
         * Encrypts a message using AES-GCM.
         * The result is a Base64 string combining Salt (16 bytes), IV (12 bytes), and Ciphertext.
         * @param {string} message The plain text message.
         * @param {string} password The user password.
         * @returns {Promise<string>} Base64 encoded payload (Salt + IV + Ciphertext).
         */
        async function encryptMessage(message, password) {
            if (!message || !password) throw new Error("Message and password required.");

            const data = strToUint8(message);
            
            // Generate unique salt (16 bytes) and IV (12 bytes for AES-GCM)
            const salt = window.crypto.getRandomValues(new Uint8Array(16));
            const iv = window.crypto.getRandomValues(new Uint8Array(12));

            const key = await getKey(password, salt);
            
            const encryptedData = await window.crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                key,
                data
            );

            // Combine Salt, IV, and Ciphertext into one buffer
            const combined = new Uint8Array(salt.byteLength + iv.byteLength + encryptedData.byteLength);
            combined.set(salt, 0);
            combined.set(iv, salt.byteLength);
            combined.set(new Uint8Array(encryptedData), salt.byteLength + iv.byteLength);

            return arrayBufferToBase64(combined);
        }

        /**
         * Decrypts an encrypted payload.
         * @param {string} encryptedBase64 Base64 encoded payload (Salt + IV + Ciphertext).
         * @param {string} password The user password.
         * @returns {Promise<string>} The decrypted plain text message.
         */
        async function decryptMessage(encryptedBase64, password) {
            if (!encryptedBase64 || !password) throw new Error("Encrypted message and password required.");

            const combined = base64ToArrayBuffer(encryptedBase64);
            
            // 28 bytes required for Salt (16) and IV (12)
            if (combined.byteLength < 28) { 
                throw new Error("Invalid payload: too short.");
            }

            // Separate the salt, IV, and encrypted data
            const salt = combined.slice(0, 16);
            const iv = combined.slice(16, 28);
            const encryptedData = combined.slice(28);

            const key = await getKey(password, salt);
            
            // Decrypts and verifies the authentication tag automatically
            const decryptedData = await window.crypto.subtle.decrypt(
                { name: "AES-GCM", iv: iv },
                key,
                encryptedData
            );

            return uint8ToStr(new Uint8Array(decryptedData));
        }


        // --- UI State Management Functions ---

        /**
         * Shows a modal with a given message.
         * @param {string} message The message to display in the modal.
         */
        function showModal(message) {
            modalMessageText.textContent = message;
            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        /**
         * Closes the currently open modal.
         */
        function closeModal() {
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        }

        /**
         * Updates the UI to show a loading state for the specified button.
         * @param {HTMLElement} btn The button element to update.
         * @param {string} text The text to show on the button.
         * @param {boolean} isLoading Whether the button is in a loading state.
         */
        function showLoading(btn, text, isLoading) {
            btn.innerHTML = isLoading ? `<div class="spinner"></div>` : text;
            btn.disabled = isLoading;
            btn.classList.toggle('opacity-50', isLoading);
            btn.classList.toggle('cursor-not-allowed', isLoading);
        }

        /**
         * Shows a status message to the user and updates the UI.
         * @param {string} message The message to display.
         * @param {string} color The color of the message (Tailwind class).
         */
        function showStatus(message, color = 'text-[#E879F9]') {
            statusMessage.textContent = message;
            // Note: Directly using hex code in Tailwind class list is generally not supported, 
            // but we use custom CSS variables for the default color and use built-in classes 
            // like text-green-500/text-red-500 for error/success.
            statusMessage.style.color = color.startsWith('text-') ? '' : color; // Use inline style for custom hex
            statusMessage.className = `font-semibold min-h-[20px] text-sm mb-4 ${color.startsWith('text-') ? color : ''}`;
        }

        /**
         * Resets the UI to its initial state.
         */
        function resetUI() {
            messageInput.value = '';
            passwordInput.value = '';
            showStatus('', 'text-transparent'); // Clear status
            progressBar.style.width = '0%';
            downloadLink.classList.add('hidden');
            showLoading(hideBtn, 'Encrypt', false);
            showLoading(revealBtn, 'Decrypt', false);
        }
        
        // --- Main Steganography Logic (Asynchronous) ---

        /**
         * Hides a message in an image asynchronously.
         * @param {Uint8ClampedArray} data The image pixel data.
         * @param {string} binarySecret The binary string of the secret message.
         * @param {number} totalBits The total number of bits to hide.
         * @param {number} startIndex The starting index for processing.
         * @param {function} onComplete Callback function to execute on completion.
         */
        function hideMessageAsync(data, binarySecret, totalBits, startIndex, onComplete) {
            let i = startIndex;
            const end = Math.min(startIndex + CHANNELS_PER_CHUNK, totalBits);

            const hideStep = () => {
                for (; i < end; i++) {
                    const pixelIndex = Math.floor(i / 3) * 4;
                    const channelIndex = i % 3;
                    const value = data[pixelIndex + channelIndex];
                    const secretBit = parseInt(binarySecret[i], 2);

                    data[pixelIndex + channelIndex] = (value & ~1) | secretBit;
                }

                updateProgress((i / totalBits) * 100);

                if (i < totalBits) {
                    requestAnimationFrame(() => hideMessageAsync(data, binarySecret, totalBits, i, onComplete));
                } else {
                    onComplete();
                }
            };
            requestAnimationFrame(hideStep);
        }

        /**
         * Reveals a message from an image asynchronously.
         * @param {Uint8ClampedArray} data The image pixel data.
         * @param {function} onComplete Callback function with the extracted binary string.
         */
        function revealMessageAsync(data, onComplete) {
            let i = 0;
            let binarySecret = '';
            let isComplete = false;

            const revealStep = () => {
                const end = Math.min(i + CHANNELS_PER_CHUNK, data.length);
                let secretMessage = '';

                for (; i < end && !isComplete; i += 4) {
                    binarySecret += (data[i] & 1).toString();
                    binarySecret += (data[i + 1] & 1).toString();
                    binarySecret += (data[i + 2] & 1).toString();
                    
                    if (binarySecret.length % 8 === 0) {
                        secretMessage = fromBinary(binarySecret);
                        if (secretMessage.includes('###END_OF_MESSAGE###')) {
                            isComplete = true;
                            break;
                        }
                    }
                }

                updateProgress((i / data.length) * 100);
                
                if (isComplete) {
                    onComplete(binarySecret);
                } else if (i < data.length) {
                    requestAnimationFrame(revealStep);
                } else {
                    onComplete(''); // No message found
                }
            };
            requestAnimationFrame(revealStep);
        }

        // --- Event Listeners ---

        hideBtn.addEventListener('click', async () => {
            const imageFile = imageInput.files[0];
            const message = messageInput.value;
            const password = passwordInput.value;
            
            if (!imageFile || !message || !password) {
                showModal('Please upload an image, type a message, and enter a password to hide.');
                return;
            }

            showLoading(hideBtn, 'Hiding...', true);
            showStatus('Preparing image...');
            downloadLink.classList.add('hidden');
            
            try {
                // 1. Encrypt message using Web Crypto API
                showStatus('Encrypting message with PBKDF2...');
                // encryptedPayload is a Base64 string containing (Salt + IV + Ciphertext)
                const encryptedPayload = await encryptMessage(message, password);
                
                // 2. Prepare the payload for steganography
                const secretData = encryptedPayload + '###END_OF_MESSAGE###';
                const binarySecret = toBinary(secretData);

                // 3. Load image and hide the binary data
                const reader = new FileReader();
                reader.readAsDataURL(imageFile);
                reader.onloadend = () => {
                    const img = new Image();
                    img.onload = () => {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);

                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        
                        const availableSpace = (data.length / 4) * 3;
                        if (binarySecret.length > availableSpace) {
                             showModal('Message is too long for this image. Please use a larger image or a shorter message.');
                             showLoading(hideBtn, 'Encrypt', false);
                             return;
                        }

                        showStatus('Hiding message in pixels...');
                        hideMessageAsync(data, binarySecret, binarySecret.length, 0, () => {
                            ctx.putImageData(imageData, 0, 0);
                            const newImageUrl = canvas.toDataURL('image/png');
                            downloadLink.href = newImageUrl;
                            downloadLink.classList.remove('hidden');
                            
                            showStatus('Message hidden! Click the link below to download.', 'text-green-500'); /* Success is Green for contrast */
                            updateProgress(100);
                            showLoading(hideBtn, 'Encrypt', false);
                        });
                    };
                    img.src = reader.result;
                };
            } catch (error) {
                showStatus('An error occurred during hiding. Please try again.', 'text-red-500');
                showLoading(hideBtn, 'Encrypt', false);
                console.error("Encryption/Hiding Failed:", error);
            }
        });

        revealBtn.addEventListener('click', async () => {
            const imageFile = imageInput.files[0];
            const password = passwordInput.value;
            
            if (!imageFile || !password) {
                showModal('Please upload a steganographic image and enter a password to reveal.');
                return;
            }
            
            showLoading(revealBtn, 'Revealing...', true);
            showStatus('Loading image and revealing message...');
            
            try {
                const reader = new FileReader();
                reader.readAsDataURL(imageFile);
                reader.onloadend = () => {
                    const img = new Image();
                    img.onload = () => {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
        
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        
                        showStatus('Extracting message from pixels...');
                        revealMessageAsync(data, async (binarySecret) => {
                            if (!binarySecret) {
                                showModal('No hidden message found or the image is corrupted.');
                                showStatus('No hidden message found.', 'text-red-500');
                                showLoading(revealBtn, 'Decrypt', false);
                                return;
                            }
                            
                            const secretMessageWithSeparator = fromBinary(binarySecret);
                            const [encryptedPayload, separator] = secretMessageWithSeparator.split('###END_OF_MESSAGE###');
                            
                            if (separator === undefined) {
                                showModal('Could not find the end of the message. The image may be corrupted.');
                                showStatus('Extraction failed.', 'text-red-500');
                                showLoading(revealBtn, 'Decrypt', false);
                                return;
                            }

                            showStatus('Decrypting message...');
                            try {
                                // 1. Decrypt payload using Web Crypto API
                                const decryptedMessage = await decryptMessage(encryptedPayload, password);
                                
                                messageInput.value = decryptedMessage;
                                showStatus('Message revealed successfully!', 'text-green-500'); /* Success is Green for contrast */
                            } catch (e) {
                                // Catch-all for failed decryption (bad password, corrupt data, invalid tag, etc.)
                                showModal('Decryption failed. The password may be incorrect or the image data is invalid.');
                                showStatus('Decryption failed. Invalid password or corrupted message.', 'text-red-500');
                                console.error("Decryption Failed:", e);
                            }
                            updateProgress(100);
                            showLoading(revealBtn, 'Decrypt', false);
                        });
                    };
                    img.src = reader.result;
                };
            } catch (error) {
                showStatus('An error occurred during revealing. Please try again.', 'text-red-500');
                showLoading(revealBtn, 'Decrypt', false);
                console.error("Revealing Failed:", error);
            }
        });

        // --- Helper Functions for Data Conversion (Steganography) ---

        function toBinary(str) {
            return str.split('').map(char => char.charCodeAt(0).toString(2).padStart(8, '0')).join('');
        }

        function fromBinary(bin) {
            const bytes = [];
            for (let i = 0; i < bin.length; i += 8) {
                bytes.push(parseInt(bin.substring(i, i + 8), 2));
            }
            return String.fromCharCode(...bytes);
        }

        function updateProgress(progress) {
            progressBar.style.width = `${progress}%`;
        }

        // --- UI Interactions ---
        passwordToggle.addEventListener('click', () => {
            const isPassword = passwordInput.type === 'password';
            passwordInput.type = isPassword ? 'text' : 'password';
            const iconPath = isPassword ? 
                `<svg class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.09 9.09 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19M1 1l22 22" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/><circle cx="12" cy="12" r="3" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/></svg>` : 
                `<svg class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>`;
            passwordToggle.innerHTML = iconPath;
        });

        imageInput.addEventListener('change', resetUI);
    </script>

        <!-- Footer -->
    <footer class="bg-[#0D0D0D] text-center p-6 mt-8">
        <p>Encryption Hub v1.0.3 - <a href="https://www.gnu.org/licenses/gpl-3.0.html" class="text-[#E879F9] hover:underline">GPLv3 Licensed</a></p>
        <p class="text-gray-400">Copyright © 2025 Azeem117.</p>
    </footer>
   <script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      // The scope path is crucial for GitHub Pages subdirectories!
      navigator.serviceWorker.register('/EncryptionHub.github.io/sw.js', {
          scope: '/EncryptionHub.github.io/' 
        })
        .then(registration => {
          console.log('Service Worker registered with scope:', registration.scope);
        })
        .catch(error => {
          console.error('Service Worker registration failed:', error);
        });
    });
  }
</script>
</body>
</html>
